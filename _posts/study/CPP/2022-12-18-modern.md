---
title: Modern C++
layout: post
category: study
tags: [c++]
---

### Modern C++

여기에서는 C++11, C++14, and C++17 에대해서 게임 개발에 필요한것부터 정리 하겠다. 아래의 목록과 같이 설명을 하고, 더 설명이 필요한 부분이 있다면, 아래에 더 섹션을 추가할 예정이다.

### Auto

C++ 에서는 variable 앞에 항상 타입이 있었다. 예를 들어서, 함수의 인자 타입을 제약조건에서 벗어나려면, template 을 사용해서 하는 방법이 있었다. 하지만, 뭔가 파이썬 처럼 자동 추론 해주는 키워드가 있을까? 생각이든다. 정답은 있다. 일종의 조커 카드 키워드 인 `auto` 라는 키워드가 있다. 즉 이 키워드가 하는 역활은 compiler 에게 type deduction 을 부탁하는거다. (알아서 잘 맞춰봐 라는 명령을 날리는것 하고 똑같다.) 하지만, compiler 에게 맡기는건 항상 언제나 문제를 일으킨다. 예를들어서, 참조나 포인터 값을 추론 하라고 한다고 하면, 또한 const 를 사용한다면 어떻게 될까? 라는 질문을 할수 있다.

```c++

```

물론 auto 가 주는 편의한 점도 있다. 하지만 이것을 무분별하게 사용한다면 readability 또 떨어지지만, 진짜 진짜 타이핑이 길어지는 경우는 지양해야한다. 예를 들어서, loop 에 `iterator` 를 정의할때는 지향한다.

### Brace {} Initialization

그다음은 brace {} Intialization 이다. 최신 OpenSource 를 보다보면 {} 이런식으로 사용하는걸 볼수 있다. 일단 variable initialization 을 보자. 처음에 `int a = 10;` 기존에는 이렇게 Initialization 을 했었다. 하지만 또 다른 방법은, 그 아래와 같이 `{}` b 와 c 를 0 으로 initialize 한걸 볼수 있다. 또 확인을 해보면 vector 등 container 초기화랑 되게 잘어울린다는걸 확인 할 수 잇다. 그리고 중괄호의 초기화 같은 경우, 축소 반환 방지라는게 있다. 이 말은 type conversion 이 깐깐해진다. 

아래에서 또 `intializer_list` 라는게 있는데 만약 list 로 받는다고 가정을 할때, 만약에 생성자에 인자를 두개나 세개만 받는게 있다고 하면 initializer_list 의 생성자가 호출이 된다. 즉, 우선권을 얻어버린다.

```c++
#include <iostream>
#include <vector>
using namespace std;

class Knight
{
public:
    Knight(){}
    Knight(int a, int b){} 
    Knight(initializer_list<int> li) // 초기화할때 리스트
    {
        cout << "Knight(Initialize List)" << endl;
    }
}

int main()
{
    int a = 10;
    int b{0};                   // int b(0);
    int c{0};                   // int c(0):

    Knight k1;
    Knight k2 = k1              // 복사 생성자 (대입 연산자)
    Knight k3 { k2 };           // Knight 초기화

    vector<int> v1{1, 2, 3, 4}; // vector 초기화 1, 2, 3, 4 push_back

    int x = 0;
    double y{x};                // error

    Knight k4{};                // 기본생성자

    Knight k5{1, 2, 3, 4, 5};
    return 0;
}
```

결론을 내자면 괄호 초기화할때 `()` 기본으로 간다, 뭔가 모던함을 보여주려면 `{}` 사용해도 된다. 근데 주로 vector 같은 경우에는 `{}` 초기화해도 된다.

### nullptr

C 코드나 C style 인 C++ 코드에서 보면 `NULL` 을 종종 볼수 있을거다. 실제 이 값을 보면 0 이라는 값을 가지고 있다. 에를 들어서, `#define NULL 0` 이렇게 선언이 되어있어서 사용되었었다. 그런데 문제점은 만약 함수에서 정수 인자로 받는것과 pointer 로 받는게 있다고 하면 Null로 넘겨주면 정수인자로 받는 함수만 사용된다. 그래서 `nullptr` 의 자주 사용되며, 장점이된다. 도대체 그럼 nullptr 은 더 객체같은 존재다. 아래의 코드는 간단한 `nullptr` 의 구현부이다.

* 보너스 : 선언하자마자 객체를 만들고 싶다면 class 뒤에, instantiate 하고 싶은 name 을 주면 된다.

```c++
class NullPtr
{
public:
    // 그 어떤 타입의 포인터와도 치환 가능
    template<typename T>
    operator T*() const
    {
        return 0;
    }
    // 그 어떤 타입의 멤버 포인터와도 치환 가능
    template<typename C, typename T>
    operator T C::*() const
    {
        return 0;
    }
    void operator&() = delete; // 주소갑 & 을 막는다.
};
```

### using

전에는 typedef 를 사용했던 이유는 뭔가 type 이름이 길어졌을때, 다른 이름으로 만든다음에 설정을 해주었었다. 사실 modern c++ 에서 `using` 을 사용하는게 결국은 typedef 랑 같다. 근데 사용하는 방법의 차이점을 알고 사용하면 굉장히 괜찮은 코드가 나올것이 분명하다. 한번 사용해보는 코드를 봐보자. 일단 `using` 을 사용함으로써 되게 가독성이 올라간다. 그리고 제일 중요한건 `template` 의 사용이다. `typedef` 는 template 을 사용할수 없다.

```c++

typedef __int64 id;
using id2 = int;

// 1 ) 직관성
typedef void (*MyFunc)();
using MyFunc2 = void(*)();

// 2) Template
template<typename T>
using List = std::list<T>;

// 과거엔
template<typename T>
struct List2
{
    typedef std::list<T> type;
};

int main()
{
    List2<int>::type li2;
}
```

### enum class

enum 은 너무 친숙하지만, modern c++ 에서는 살짝 나누어져있다. 일단 `enum class` 의 장점을 알아보자.

1. 이름 공간 관리 (scoped)
2. 암묵적인 변환 금지

일단 아래와 같이 봤을때, 만약 enum 값들 중에 같은값을 가지고 있으면, 재정의가 필요하다고 에러창을 보여지는걸 볼수 있다. 그래서 이게 전의 enum 의 단점이다. `보너스: enum 의 Type 을 지정이 가능하다.` 그래서 `enum class` 를 사용해서 enum 의 범위를 지정시켜줘서, 똑같은 element 가 enum 에 있다고 한들 문제가 없어진다.

```c++
// unscped enum
enum PlayerType
{
    PT_Knight,
    PT_Archer,
    PT_Mage
}

enum PlayerType : char
{
    PT_Knight,
    PT_Archer,
    PT_Mage,
}

enum MonsterType
{
    PT_Knight // 실수로
}

enum class ObjectType
{
    Player,
    Monster,
    Projectile,
}

int main()
{
    double value = PT_Knight;                               // 에전의 enum 을 사용했을시 허용됬었다.

    double value = ObjectType::Player;                      // 허용 x
    double value = static_cast<double>(ObjectType::Player)  // 명시적만 허용
}
```

### delete

어? 설마 동적 할당에 대한 `delete` 였나? 라고 생각할수 있지만, 그런 keyword 가 아니다. 가끔씩은 compiler 에게 기본적으로 만들어진 생성자나 복사생성자를 부를때가 있다. 그럴때 뭔가 막고자 할때 그 함수를 없앤다가 더 말이 맞다. 과거의 코드를 한번 봐보자

```c++
class Knight
{
public:

private:
    // 정의도지 않은 비공개 (private) 함수 --> 하지만 구현부에서는 돌아갈수있다. 그래서 완벽하게 막는 행위는 아니다.
    void operator=(const Knight& k);
    friend class Admin; // admin 에게는 허락 해주겠다.
private:
    int _hp = 100;
}

class Admin
{
public:
    void CopyKnight(const Knight& k)
    {

    }
}

int main()
{
    Knight k1;
    Knight k2;

    // 복사 연산자
    k1 = k2;
    return 0;
}
```

과연 modern c++ 에서는 이걸 어떻게 해결했을까?

```c++
class Knight
{
public:
    void operator=(const Knight& k) = delete
}

class Admin
{
public:
    void CopyKnight(const Knight& k)
    {

    }
}

int main()
{
    Knight k1;
    Knight k2;

    // 복사 연산자
    k1 = k2; // delete 되버림
    return 0;
}
```

### override and final

c# 에서 뭔가 친숙한 keyword 이지만, c++ 에서 어떻게 사용됬는지 한번 확인을 해보자.

```c++
class Creature
{
public:
};

class Player : public Creature
{
public:
    virtual void Attack()
    {
        cout << "Player Attack" << endl;
    }
};

class Knight : public Player
{
public:
    virtual void Attack() override
    {
        cout << "Kngiht" << endl;
    }
    virtual void Attack() const //  member 변수를 변경 할수 없음
private:
    int _stamina = 100;
};

class Pet : public Knight
{
public:
    virtual void Attack() final // 마지막 봉인 : 자식에게 그만 주겠당
    {
        cout << "Pet" << endl;
    }
};

int main()
{
    Player* player = new Knight();
    player->Attack();
    return 0;
}
```

### rvalue

### forwarding reference

### lambda

### smart pointer

smart pointer 포인터가 똑똑하다? C++ 의 장점이자 단점은 Memory 를 직접 건든다는거다. 하지만 단점중에 알아볼건 바로 dangling pointer 이다.
잠깐 살펴보자. 아래의 코드를 보자면, 뭔가 `Knight` 에 대한 세팅을 다해줬는데, `_target` 을 지워버린 셈이다. 이럴때 문제가 바로 crash 가 일어나지 않고, `_target->_hp` 에 쓰레기 값이 들어가 있는걸 볼수 있다. 즉 `_target` 에 참조하고 있는애들을 다 nullptr 로 바꿔줘야한다. 

```c++
class Knight
{
public:
    Knight(){}
    ~Knight(){}
    void Attack()
    {
        if (_target)
        {
            _target->_hp = _damage;
            cout << "Hp:" << _target->_hp << endl;
        }
    }
public:
    int _hp = 100;
    int _damage = 10;
    Knight* _target = nullptr;
}

int main()
{
    Knight* k1 = new Knight();
    Knight* k2 = new Knight();
    k1->_target = k2;
    delete k2;
    k1->Attack();
    return 0;
}
```

조금은 성능면에서 raw pointer 를 사용하기보다는, 코드의 안정성을 위한 코드가 필요해서 smart pointer 가 생겼다. 스마트 포인터란 포인터를 알맞는 정책에 따라 관리하는 객체 (포인터를 래핑해서 사용) 되었다. smart pointer 안에 종류는 아래와 같다

1. shared_ptr
2. weak_ptr
3. unique_ptr

smart pointer 안에서는, python 이나 c# 에서 Garbage Collector 에서 사용되는 reference count 를 해준다. 즉 아무도 사용하지 않을때, delete 를 해준다. 여기에서 중요한점은 RefCount = 1 로 세팅이 되어있고, 소멸할때는 0 으로 만들어준다음, 0 일때 지워주는게 보인다. (즉 refCount 를 확인하고 지워준다는게 특징이다.) 아래의 코드는 shared_ptr 이 어떻게 동작하는지를 확인할수있다.

```c++
class RefCountBlock
{
public:
    int _refCount = 1; // 기본 값은 1. 
};

template<typename T>
class SharedPtr
{
public:
    SharedPtr(){}
    SharedPtr(T* ptr) : _ptr(ptr)
    {
        if (_ptr != nullptr)
        {
            _block = new RefCountBlock();
            cout << "RefCount : " << _block->_refCount << endl;
        }
    }
    SharedPtr(const SharedPtr& shared_ptr) : _ptr(shared_ptr._ptr), _block(shared_ptr._block)
    {
        if(_ptr != nullptr)
        {
            _block->_refCount++;
        }
    }
    ~SharedPtr()
    {
        if(_ptr != nullptr)
        {
            _block->_refCount--;

            // delete _ptr

            if (_block->_refCount ==0)
            {
                delete _ptr;
                delete _block;
            }
        }
    }

    void operator=(const SharedPtr& shared_ptr)
    {
        _ptr = shared_ptr._ptr;
        _block = shared_ptr._block;
    }
public:
    T* _ptr = nullptr;
    RefCountBlock* _block = nullptr; 
};

int main()
{
    SharedPtr<Knight> k1(new Knight());
    SharedPtr<Knight> k2 = k1;

    SharedPtr<Knight> k3;
    {
        SharedPtr<Knight>k4(new Knight());
        k4 = k1;
    }
}
```

아래의 코드는 shared_ptr 를 직접 사용한 코드이다.

```c++
class Knight
{
public:
    Knight(){}
    ~Knight(){}
    void Attack()
    {
        if (_target)
        {
            _target->_hp = _damage;
            cout << "Hp:" << _target->_hp << endl;
        }
    }
public:
    int _hp = 100;
    int _damage = 10;
    shared_ptr<Knight> _target = nullptr;
}

int main()
{
    shared_ptr<Knight> k1 = make_shared<Knight>(); // 빨리 동작
    {
        shared_ptr<Knight> k2 = make_shared<Knight>();
        k1->_target = k2;
    }

    k1->Atttack();
    return 0;
}
```

하지만 shared_ptr 를 사용한다고 하더라도, 포인터의 똑같은 문제점인 순환구조에서는 refCount 가 0 이 되지 않아서, 큰문제가 있을거다. 아래의 예제 code segment 를 봐보자. 아래의 경우 `k1` 에서의 refCount 는 2 이고, `k2` 에서의 refCount 가 1 이기때문에 아무도 delete 를 안할것이다.
그래서, 순환구조로 있을때는 따로 nullptr 로 풀어줘야한다.

```c++
shared_ptr<Knight> k1 = make_sahred<Knight>();
{
    shared_ptr<Knight> k2 = make_shared<Knight>();
    k1 -> _target = k2;
    k2 -> _target = k1;
}

k1->_target = nullptr;
k2->_target = nullptr;
```

또다른 방법은 `weak_ptr` 를 사용한다. `weak_ptr` 를 사용함에따라서, ReferenceBlock 에는 또다른 `_weakCount` 라는게 생긴다. `shared_pointer` 와 달리, `weak_ptr` 같은 경우는 메모리가 날라갔는지 안날라갔는지 확인이 가능하다. 그래서 `.expred()` 를 사용해서 날라갔는지 안날라갔는지를 통해서, 그 ptr 를 `lock` 을 할수 있다. 즉 `weak_ptr` 는 생명주기를 확인할수 없다. 즉 `shared_ptr` 과 `weak_ptr` 차이점은 메모리의 한정 범위에서 자유로워지냐, 생명주기를 확인할수 있냐 등이 있다.

### Resource

- [Inflearn: UnrealEngine Game Dev](https://www.inflearn.com/course/%EC%96%B8%EB%A6%AC%EC%96%BC-3d-mmorpg-1)
- [Auto](https://en.cppreference.com/w/cpp/language/auto)
- [Value Initialization](https://en.cppreference.com/w/cpp/language/value_initialization)
- [nullptr]()
- [using]()
- [enum class]()
- [delete]()
- [override and final]()
- [rvalue]()
- [forwarding reference]()
- [lambda]()
- [smart pointer]()

### Source Code
- [Modern C++](https://github.com/sjang1594/self-study/tree/master/game_dev/cpp/modern_cpp)