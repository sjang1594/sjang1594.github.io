---
title: Modern C++
layout: post
category: study
tags: [c++]
---

### Modern C++

여기에서는 C++11, C++14, and C++17 에대해서 게임 개발에 필요한것부터 정리 하겠다. 아래의 목록과 같이 설명을 하고, 더 설명이 필요한 부분이 있다면, 아래에 더 섹션을 추가할 예정이다.

### Auto

C++ 에서는 variable 앞에 항상 타입이 있었다. 예를 들어서, 함수의 인자 타입을 제약조건에서 벗어나려면, template 을 사용해서 하는 방법이 있었다. 하지만, 뭔가 파이썬 처럼 자동 추론 해주는 키워드가 있을까? 생각이든다. 정답은 있다. 일종의 조커 카드 키워드 인 `auto` 라는 키워드가 있다. 즉 이 키워드가 하는 역활은 compiler 에게 type deduction 을 부탁하는거다. (알아서 잘 맞춰봐 라는 명령을 날리는것 하고 똑같다.) 하지만, compiler 에게 맡기는건 항상 언제나 문제를 일으킨다. 예를들어서, 참조나 포인터 값을 추론 하라고 한다고 하면, 또한 const 를 사용한다면 어떻게 될까? 라는 질문을 할수 있다.

```c++

```

물론 auto 가 주는 편의한 점도 있다. 하지만 이것을 무분별하게 사용한다면 readability 또 떨어지지만, 진짜 진짜 타이핑이 길어지는 경우는 지양해야한다. 예를 들어서, loop 에 `iterator` 를 정의할때는 지향한다.

### Brace {} Initialization

그다음은 brace {} Intialization 이다. 최신 OpenSource 를 보다보면 {} 이런식으로 사용하는걸 볼수 있다. 일단 variable initialization 을 보자. 처음에 `int a = 10;` 기존에는 이렇게 Initialization 을 했었다. 하지만 또 다른 방법은, 그 아래와 같이 `{}` b 와 c 를 0 으로 initialize 한걸 볼수 있다. 또 확인을 해보면 vector 등 container 초기화랑 되게 잘어울린다는걸 확인 할 수 잇다. 그리고 중괄호의 초기화 같은 경우, 축소 반환 방지라는게 있다. 이 말은 type conversion 이 깐깐해진다. 

아래에서 또 `intializer_list` 라는게 있는데 만약 list 로 받는다고 가정을 할때, 만약에 생성자에 인자를 두개나 세개만 받는게 있다고 하면 initializer_list 의 생성자가 호출이 된다. 즉, 우선권을 얻어버린다.

```c++
#include <iostream>
#include <vector>
using namespace std;

class Knight
{
public:
    Knight(){}
    Knight(int a, int b){} 
    Knight(initializer_list<int> li) // 초기화할때 리스트
    {
        cout << "Knight(Initialize List)" << endl;
    }
}

int main()
{
    int a = 10;
    int b{0};                   // int b(0);
    int c{0};                   // int c(0):

    Knight k1;
    Knight k2 = k1              // 복사 생성자 (대입 연산자)
    Knight k3 { k2 };           // Knight 초기화

    vector<int> v1{1, 2, 3, 4}; // vector 초기화 1, 2, 3, 4 push_back

    int x = 0;
    double y{x};                // error

    Knight k4{};                // 기본생성자

    Knight k5{1, 2, 3, 4, 5};
    return 0;
}
```

결론을 내자면 괄호 초기화할때 `()` 기본으로 간다, 뭔가 모던함을 보여주려면 `{}` 사용해도 된다. 근데 주로 vector 같은 경우에는 `{}` 초기화해도 된다.

### nullptr

C 코드나 C style 인 C++ 코드에서 보면 `NULL` 을 종종 볼수 있을거다. 실제 이 값을 보면 0 이라는 값을 가지고 있다. 에를 들어서, `#define NULL 0` 이렇게 선언이 되어있어서 사용되었었다. 그런데 문제점은 만약 함수에서 정수 인자로 받는것과 pointer 로 받는게 있다고 하면 Null로 넘겨주면 정수인자로 받는 함수만 사용된다. 그래서 `nullptr` 의 자주 사용되며, 장점이된다. 도대체 그럼 nullptr 은 더 객체같은 존재다. 아래의 코드는 간단한 `nullptr` 의 구현부이다.

* 보너스 : 선언하자마자 객체를 만들고 싶다면 class 뒤에, instantiate 하고 싶은 name 을 주면 된다.

```c++
class NullPtr
{
public:
    // 그 어떤 타입의 포인터와도 치환 가능
    template<typename T>
    operator T*() const
    {
        return 0;
    }
    // 그 어떤 타입의 멤버 포인터와도 치환 가능
    template<typename C, typename T>
    operator T C::*() const
    {
        return 0;
    }
    void operator&() = delete; // 주소갑 & 을 막는다.
};
```

### using

전에는 typedef 를 사용했던 이유는 뭔가 type 이름이 길어졌을때, 다른 이름으로 만든다음에 설정을 해주었었다. 사실 modern c++ 에서 `using` 을 사용하는게 결국은 typedef 랑 같다. 근데 사용하는 방법의 차이점을 알고 사용하면 굉장히 괜찮은 코드가 나올것이 분명하다. 한번 사용해보는 코드를 봐보자. 일단 `using` 을 사용함으로써 되게 가독성이 올라간다. 그리고 제일 중요한건 `template` 의 사용이다. `typedef` 는 template 을 사용할수 없다.

```c++

typedef __int64 id;
using id2 = int;

// 1 ) 직관성
typedef void (*MyFunc)();
using MyFunc2 = void(*)();

// 2) Template
template<typename T>
using List = std::list<T>;

// 과거엔
template<typename T>
struct List2
{
    typedef std::list<T> type;
};

int main()
{
    List2<int>::type li2;
}
```

### enum class

enum 은 너무 친숙하지만, modern c++ 에서는 살짝 나누어져있다. 일단 `enum class` 의 장점을 알아보자.

1. 이름 공간 관리 (scoped)
2. 암묵적인 변환 금지

일단 아래와 같이 봤을때, 만약 enum 값들 중에 같은값을 가지고 있으면, 재정의가 필요하다고 에러창을 보여지는걸 볼수 있다. 그래서 이게 전의 enum 의 단점이다. `보너스: enum 의 Type 을 지정이 가능하다.` 그래서 `enum class` 를 사용해서 enum 의 범위를 지정시켜줘서, 똑같은 element 가 enum 에 있다고 한들 문제가 없어진다.

```c++
// unscped enum
enum PlayerType
{
    PT_Knight,
    PT_Archer,
    PT_Mage
}

enum PlayerType : char
{
    PT_Knight,
    PT_Archer,
    PT_Mage,
}

enum MonsterType
{
    PT_Knight // 실수로
}

enum class ObjectType
{
    Player,
    Monster,
    Projectile,
}

int main()
{
    double value = PT_Knight;                               // 에전의 enum 을 사용했을시 허용됬었다.

    double value = ObjectType::Player;                      // 허용 x
    double value = static_cast<double>(ObjectType::Player)  // 명시적만 허용
}
```

### delete

어? 설마 동적 할당에 대한 `delete` 였나? 라고 생각할수 있지만, 그런 keyword 가 아니다. 가끔씩은 compiler 에게 기본적으로 만들어진 생성자나 복사생성자를 부를때가 있다. 그럴때 뭔가 막고자 할때 그 함수를 없앤다가 더 말이 맞다. 과거의 코드를 한번 봐보자

```c++
class Knight
{
public:

private:
    // 정의도지 않은 비공개 (private) 함수 --> 하지만 구현부에서는 돌아갈수있다. 그래서 완벽하게 막는 행위는 아니다.
    void operator=(const Knight& k);
    friend class Admin; // admin 에게는 허락 해주겠다.
private:
    int _hp = 100;
}

class Admin
{
public:
    void CopyKnight(const Knight& k)
    {

    }
}

int main()
{
    Knight k1;
    Knight k2;

    // 복사 연산자
    k1 = k2;
    return 0;
}
```

과연 modern c++ 에서는 이걸 어떻게 해결했을까?

```c++
class Knight
{
public:
    void operator=(const Knight& k) = delete
}

class Admin
{
public:
    void CopyKnight(const Knight& k)
    {

    }
}

int main()
{
    Knight k1;
    Knight k2;

    // 복사 연산자
    k1 = k2; // delete 되버림
    return 0;
}
```

### override and final

c# 에서 뭔가 친숙한 keyword 이지만, c++ 에서 어떻게 사용됬는지 한번 확인을 해보자.

```c++
class Creature
{
public:
};

class Player : public Creature
{
public:
    virtual void Attack()
    {
        cout << "Player Attack" << endl;
    }
};

class Knight : public Player
{
public:
    virtual void Attack() override
    {
        cout << "Kngiht" << endl;
    }
    virtual void Attack() const //  member 변수를 변경 할수 없음
private:
    int _stamina = 100;
};

class Pet : public Knight
{
public:
    virtual void Attack() final // 마지막 봉인 : 자식에게 그만 주겠당
    {
        cout << "Pet" << endl;
    }
};

int main()
{
    Player* player = new Knight();
    player->Attack();
    return 0;
}
```

### rvalue

### forwarding reference

### lambda

### smart pointer

### Resource

- [Inflearn: UnrealEngine Game Dev](https://www.inflearn.com/course/%EC%96%B8%EB%A6%AC%EC%96%BC-3d-mmorpg-1)
- [Auto](https://en.cppreference.com/w/cpp/language/auto)
- [Value Initialization](https://en.cppreference.com/w/cpp/language/value_initialization)
- [nullptr]()
- [using]()
- [enum class]()
- [delete]()
- [override and final]()
- [rvalue]()
- [forwarding reference]()
- [lambda]()
- [smart pointer]()

### Source Code
- [Modern C++](https://github.com/sjang1594/self-study/tree/master/game_dev/cpp/modern_cpp)