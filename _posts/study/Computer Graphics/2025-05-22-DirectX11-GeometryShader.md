---
title: DirectX11 - Geometry Shader & Billboards 
layout: post
category: study
tags: [directx, computer graphics, hlsl]
published: false
---

### DirectX - Geometry Pipeline

Up to now, I've been rendering using the Vertex Shader → Pixel Shader pipeline. However, as I saw in a previous post, things like subdivision don’t necessarily have to be done on the CPU— they can also be done on the GPU, and that’s where the Geometry Shader comes in.

When initializing D3D, I set the topology in the Input Assembler stage to triangle, so the input gets passed to the Vertex Shader accordingly. Likewise, when data reaches the Geometry Shader, it also receives groups of three vertices—i.e., triangles—for processing.

> "Assuming we are not using the tessellation stages, the geometry shader stage is an optional stage that sits between the vertex and pixel shader stages, While the vertext shader input vertices, the geometry shader inputs entire primitives (triangle, line, points etc..)  For example, if we were drawing triangle lists, then conceptually the geometry shader program would be executed for each triange `T` in the list
>
> for (UINT i = 0; i < numTriangles; ++i) \
>   OutputPrimitiveList = GeometryShader(T[i].vertexList)

As seen in the explanation above, it’s the same — in the end, the Geometry Shader sits between the Vertex and Pixel Shaders, and its input consists of primitives (shapes) that were generated by the Vertex Shader.

### Geometry Shader & Billboards

### Drawing Normal Vector on Geometry Shader

### Fireball

### Tesellation