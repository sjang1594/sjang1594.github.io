---
title: Pointer(Multi Pointer), Reference, Array(Multidimension)
layout: post
category: study
tags: [c++]
---

## What is Pointer ?
포인터는 한마디로 해서, 주소를 저장하고 있는 바구니라고 생각 하면 된다, 주로 포인터 사이즈는 64 비트 기준으로 8 바이트이다.
일단 사용하는 방법은 `TYPE* VAR_NAME` 이런 식으로 사용하면 된다. 그러면 딱 코드를 봤을때 어떻게 생각하면 되냐? 뭔가 *(Asterisk) 이게 등장했다하면 포인터 = 주소라고 생각하면된다.
아래와 같이 `number` 라는 variable 은 Stack Memory 에 저장이 되어있는데, 이 Stack Memory 에 주소값을 ptr 로 받아주는 느낌이라고 생각하면 된다. 그렇다면 주소의 값은 어떻게 받냐? 라고 하냐면 & (ampersand) 이렇게 받으면된다. 다시말하자면 *ptr 이라는건 주소를 저장하는 형식의 바구니라는거라고 생각하면 된다.

```c++
int number = 1;
int *ptr = &number;
```

그렇다면 이 주소를 가지고 있는 바구니가지고 뭘할수 있을까 라고 생각이든다. 값을 가지고 오는 방법은 뭐가있을까? 일단 그러기전에 변수선언(variable declartion)을 한상태에서, 사용할때는 마치 포틀을 타고 순간이동을 한거나 마찬가지라고 생각을 하면된다. 왜 갑자기 포탈이라고 생각할수 있는데. 만약 메모리를 까보면 이런식으로 되어있다. 위의 코드를 봤을때 ptr 의 값을 `&ptr` 이런식으로 가게되면 주소값이 저장된걸 확인할수 있고, 그 값을 통해서 가면 `number` 의 주소로 향하고 있다는걸 확인 할수 있다. 또한 아래의 코드를 보자면, ptr 을 타고 들어가서 그 값은 주소값이니까, 그주소로 가면 2로 변경된걸 확인 할수 있다. 즉 포탈을 타고 가서 값을 변경하는것이다. 이걸 타입면에서 생각을 해보았을때 `*` 가 있다면 ptr 을 가면 int 가 있다고 생각해도 된다. 그런데, 타입 캐스팅이 가능하기 때문에, 메모리 오염을 시킬수 있다.

```c++
int value1 = *ptr;
*ptr = 2

// but let's think about this way
// what if type is differnet
__int64* ptr2 = (__int64*)&number;
*ptr = 0x0000AABBCCDDEEFF; // this wil contaminate the memory since it will allocate extra space.
```

아래와 같은 예제는 함수에 사용될때의 예시인데, main() 안에 stack memory 에 올라간 hp 를 SetHp로 인자를 넘겨줬을때, 값은 변화하지 않는다. 값을 변화시킬려면 stack memory 안에 있는 hp 의 주소를 던져줘서 hp value 를 바꿀수 있는 예제이다.

```c++
void SetHp(int *hp)
{
    *hp = 100;
}

int main()
{
    int hp = 1;
    SetHp(&hp) // give the address.
    return 0;
}
```

### Pointer Operation
포인터 연산에는 아래와 같이 나누어진다.
1. 주소 연산자 (&)
2. 산술 연산자
3. 간접 연산자
4. 간접 멤버 연산자

주소 연산자 같은 경우는 `&` 사용해서 주소값을 가지고 올때 사용한다. 즉 해당 변수 타입에 따라서 `TYPE*` 을 return 한다. 산술 연산자 같은 경우 `+` 와 `-` 를 사용한다. 다만 나눗셈과 곱셈 연산은 사용되지 않는다. `+` 나 `-` 를 했을때 그 타입의 사이즈를 따라서 그 주소 뒤에 가거나 앞으로 간다고 생각하면 된다. 즉 타입만큼의 크기만큼 이동하는거라고 생각하면 된다. 간접 연산자 같은경우는, 우리가 포인터를 생성할때 `*` 사용했었다. 포인터란 다시말해서, `포탈을 타고가라` 라고 생각하면 됬었다 했었다. 그렇다면 간접 멤버 연산자는 뭘까? 정담은 이 친구 `->` 이다. 아래의 예제 코드를 보면, `player` 의 객체의 주소를 `playerPtr` 향하게 했었다. 그말은 `playerPtr` 에는 `player` 의 주소가 담겨져 있다 라고 생각하면 된다. 그래서 `player` 의 멤버 변수인 `_hp` 와 `_damage` 를 바꾼다고 가정했을때 아래와 같이 할수 있다. 그럼 간접연산자를 어떻게 사용할수 있을까는 그 다음 코드 segment 로 사용해도 똑같다. 즉 * 와 . 을 합친게 `->` 라고 생각하면 쉽다.

```c++
class Player()
{
public:
    int _hp;
    int _damage;
}

int main()
{
    int number = 1;
    int* ptr = &number;

    Player player;
    player._hp = 100;
    player._damage = 30;

    Player* playerPtr = &player;

    //pointer
    (*playerPtr)._hp = 200;
    (*playerPtr)._damage = 40;

    // indirect member op
    playerPtr->_hp = 300;
    playerPtr->_damage = 50;
}
```

예제 코드는 아래, resource 에 있다.

### Reference
이걸 말하기전에 바로 코드로 넘어가보자. `StatInfo` 라는 struct 를 만들어서 pointer 값을 `CreateMonster` 함수 에서 parameter 로 받았을때, hp, attack, and defence 는 각각 4 바이트씩 차지하고 있을거다. 그래서 `CreateMonster` 함수에서 인자로 넘겨줄때는 주소값(address)를 넘겨주는걸 확인할수 있다. 하지만 만약 `CreateMonster` 함수의 paramater 를 `StatInfo info` 이런 식으로 signature 가 저장이 되어있다면 어떻게 될까? 라고 생각을 하자면, 원본 데이터 즉 `main` 에 있는 info 가 인자값으로 돌아와 그 매개의 복사값을 생성하면서 값을 채워넣는다. 즉 `CreateMonster` 안에 있는 함수의 info 와 `main` 에 있는 함수는 별개의 것이며, `info` 라는 매개변수를 새로 생성해서 복사를 하는 형태가 된다. 즉 원본데이터를 수정하기 위해선 주소값을 넘겨주고, 인자선언은 pointer 로 받으면 된다는 뜻이다. 근데 결과물은 똑같다. 하지만 performance 에서 봤을땐 복사값을 만들어서 붙여넣기 하는 형태이고, 주소값을 보내는 친구는 그냥 딱 야 이거해 하는 느낌인거다.

```c++
struct StatInfo()
{
    int hp;
    int attack;
    int defence;
}

void CreateMonster(StatInfo* info)
{
    info->hp = 100;
    info->attack = 9;
    info->defence = 5;
}

int main()
{
    StatInfo info;
    CreateMonster(&info);
    return 0;
}
```

reference 놈을 알아보자. reference 는 c 에 없고 c++ 에 있는 친구인데. 일단은 low level (assembly) 단에서보면 pointer 와 동일하게 작동한다. 일단 정의 부터 알아보자.
reference 를 하고 싶다면, 아래와 같이 하면되는데. 이렇게 생까하면 된다 `number 라는 바구니에 reference 라는 다른 이름을 지어줄께`. 라고 생각하면 된다. 뭐야? reference 가 더쉽잖아. 왜 구지 포인터를 쓰면서 까지 저렇게 해 라고 되물을 수 있다. 근데 여기서 중요한건 `pass_by_reference` 와 `pass_by_pointer` 라고 생각하면 된다. 즉 함수에서 문법이 달라진다.

```c++
int number = 3;
int& reference = number;
```

아래의 코드와 같이 문법이 살짝 달라진다고 알수 있다. `pass_by_reference` 같은경우 `pass_by_pointer` 와 달리 info 값을 넣어준걸 확인 할수 있고, `pass_by_pointer` 는 `info` 의 주소값을 던져주는걸로 알수 있다. 즉 결론을 말하자면 `pass_by_reference` 와 `pass_by_pointer` 를 assembly 언어로 까보면 동작은 똑같다. 즉 performance 측면에서는 똑같다. 하지만 문법이 다른것으로 알수있으며 `pass_by_reference` 는 약간 야매로 `pass_by_value` 와 `pass_by_pointer` 의 중간지점이라고 생각하면 편할것같다.

```c++
struct StatInfo()
{
    int hp;
    int attack;
    int defence;
}

void PrintInfoByValue(StatInfo info)
{
  cout << "_________________" << endl;
  cout << info.hp << endl;
  cout << info.attack << endl;
  cout << info.defence << endl;
}

void PrintInfoByPtr(StatInfo* info)
{
  cout << "_________________" << endl;
  cout << info->hp << endl;
  cout << info->attack << endl;
  cout << info->defence << endl;
}

void PrintInfoByRef(StatInfo& info)
{
  cout << "_________________" << endl;
  cout << info.hp << endl;
  cout << info.attack << endl;
  cout << info.defence << endl;
}

int main()
{
    // ...
    StatInfo info;
    PrintInfoByValue(info);
    PrintInfoByPtr(&info);
    PrintInfoByRef(info);
}
```

### Pointer vs Reference

### Basic Array

### MultiPointer



### Resoure
- [Inflearn: UnrealEngine Game Dev](https://www.inflearn.com/course/%EC%96%B8%EB%A6%AC%EC%96%BC-3d-mmorpg-1)
- [pointer](https://github.com/sjang1594/self-study/tree/master/game_dev/cpp/pointer) 폴더에 있다.